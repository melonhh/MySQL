# MySQL
## MySQL架构
![](http://www.uml.org.cn/sjjm/images/2018032821.png)
#### 核心服务
* 包括查询解析、分析、优化、缓存以及所有内置函数
* 所有跨存储引擎的功能：存储过程、触发器、视图
#### 存储引擎
* 负责MySQL中数据的存储和提取
* 服务器通过API与存储引擎进行通信，这些接口屏蔽了不同存储引擎之间的差异，使得查询过程透明

### InnoDB存储引擎
MySQL默认的事务型存储引擎  

InnoDB的数据存储再表空间中，表空间时有InnoDB管理的一个黑盒子，由一系列的数据文件组成  

InnoDB采用MVCC来支持高并发,默认隔离级别可重复读  

InnoDB表是基于聚簇索引建立的  

## Schema 与 数据类型 优化
### 选择优化的数据类型
#### 整数类型
[UNSIGNED] TINYINT(8)、SMALLINT(16)、MEDIUMINT(24)、INT(32)、BIGINT(64)  

我们的选择决定MySQL在内存中和磁盘中如何保存数据，然而整数计算一般使用64位的BIGINT(一些聚合函数使用DECIMAL/DOUBLE进行计算)  

可以位整数类型指定宽度，但是实际上没有意义，只是规定了一些交互工具用来显示字符的个数，对于存储和计算来说无区别

#### 实数类型
实数指带小数部分的数字，然而，他们不只是为了精确存储小数，也可以存储比BIGINT还大的整数  

#### 字符串类型
VARCHAR(变长)、CHAR(定长)、BINARY() VARBINARY BLOB TEXT  

* varchar  
    * 仅使用必要的空间
    * 需要1~2个额外字节记录字符串长度（说明varchar最大长度位2^16-1）  

* char
    * 存取值时删除所有末尾空格（使用空格填充，binary使用\0填充）
    * 适合短短序列
    
* 慷慨是不明智的  
    * 使用varchar(5) 和 varchar(200) 存储 ‘hello’ 的空间是一样的
    * 但是varchar(5) 使用更少的内存

* 使用枚举ENUM代替字符串
    * 本质上存储的是数字，而不是字符串
    * 而且ORDER BY的顺序是定义的顺序，而不是按照字符串进行排序
    
#### 日期和时间类型  
DATETIME(8)、 TIMESTAMP(4)、 YEAR(1)、 DATE(3)、 TIME(3)  

MySQL能存储的最小时间粒度为秒  

大部分时间类型都没有替代品，因此没有什么事最佳选择的问题。唯一的问题是保存日期和时间的时候需要做什么  

* datetime
    * 与时区无关，YYYYMMDDHHMMSS，8个字节
* timestamp
    * 时间戳，只能表示1970年到2038年，4个字节
    * 依赖于时区，相同的timestamp在不同的MySQL服务器、操作系统、客户端表示不同的时间
    * 它的空间效率更高
    * 默认not null
    
#### 位数据类型
BIT SET
* 在InnoDB中，为每一个BIT列使用一个足够存储得最屌整数类型来存放，所以BIT不能节省存储空间

#### 选择标识符
整数类型  
    * 整数通常是标识列最好的选择，快，且可以使用AUTO_INCREMENT
    
## 创建高性能的索引
### 索引基础
索引类型  

MySQL只能高效的使用索引的最左前缀列（列的选择和顺序也十分重要）  

#### B-Tree（其实是B+树实现）
* B-Tree意味着所有的值都按顺序存储，且叶子页到跟的距离相同
* B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据  

B-Tree索引适用于：
    * 全键值查找
    * 键值范围查找
    * 键前缀查找  
    
B-Tree的限制：
    * 不能跳过索引中的列
    * 如果查询中有某个列的范围查询，那么该列右边所有列都无法使用索引优化查询 

#### 哈希索引
* 只有Memory引擎显式支持哈希索引
* 只有精确匹配索引所有列的查询才有效  

哈希索引的限制：  
    * 哈希索引只包含哈希值和行指针，不存储字段值
    * 无法用于排序
    * 不支持部分索引列匹配
    * 只支持等值操作
    * 哈希冲突时必须遍历链表中所有行指针，逐行进行比较  
    
InnoDB的自适应哈希索引（内部行为）：  
    * 当InnoDB注意到某些索引值被使用非常频繁时，它回内存中基于B-Tree索引之上再创建一个哈希索引
    * 也就是索引上的索引
    
#### 全文索引
#### 空间数据索引

#### 索引的优点
* 索引大大减少服务器需要扫描的数据量
* 索引可以帮助服务器避免排序和临时表
* 索引可以将随机IO变成顺序IO

#### 聚簇索引
聚簇索引并不是一种单独的索引类型，而是一种数据存储方式（具体细节依赖于其实现方式）  

InnoDB聚簇索引
* 当表有聚簇索引时，它的数据行实际上存放在索引的叶子页
* 聚簇 指 数据行和键值紧凑地存储在一起
* 一个表只能有一个聚簇索引（因为无法同时将数据行存放在两个不同的地方）
* InnoDB通过主键聚集数据  

InnoDB通过主键聚集数据
* 如果没有定义主键，则选择一个唯一的非空索引代替
* 如果没有索引，InnoDB回隐式定义一个主键来作为聚簇索引
* InnoDB只聚集在同一页面中的记录（一个页面可以认为是一块具有一定大小的连续存储区域）

聚簇索引的优点：
* 可以把相关数据保存在一起。比如电子邮箱，可以根据用户ID来聚集数据  

聚簇索引的缺点：
* 插入熟读严重依赖于插入顺序，按照主键的顺序插入速度最快
* 更新聚簇索引列的代价很高（这样，强制InnoDB将每个列移动到新位置）
* 插入新行或主键更新，可能回导致页分裂---导致表占用更多磁盘空间  

二级索引：
存储引擎需要在二级索引中找到相应的叶子节点，获取行的主键，然后使用主键去聚簇索引中查找记录

#### InnoDB和MyISAN的数据分布对比
MyISAM的数据分布  

MyISAM按照数据插入的顺序存储在磁盘上